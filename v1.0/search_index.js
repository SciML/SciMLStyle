var documenterSearchIndex = {"docs":
[{"location":"#SciML-Style-Guide-for-Julia","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"(Image: SciML Code Style) (Image: Global Docs)","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"The SciML Style Guide is a style guide for the Julia programming language. It is used by the SciML Open Source Scientific Machine Learning Organization. As such, it is open to discussion with the community. Please file an issue or open a PR to discuss changes to the style guide.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Table of Contents","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"SciML Style Guide for Julia\nCode Style Badge\nOverarching Dogmas of the SciML Style\nConsistency vs Adherence\nCommunity Contribution Guidelines\nOpen source contributions are allowed to start small and grow over time\nGeneric code is preferred unless code is known to be specific\nInternal types should match the types used by users when possible\nTrait definition and adherence to generic interface is preferred when possible\nMacros should be limited and only be used for syntactic sugar\nErrors should be caught as high as possible, and error messages should be contextualized for newcomers\nSubpackaging and interface packages is preferred over conditional modules via Requires.jl\nFunctions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable\nOut-Of-Place and Immutability is preferred when sufficient performant\nTests should attempt to cover a wide gamut of input types\nWhen in doubt, a submodule should become a subpackage or separate package\nGlobals should be avoided whenever possible\nType-stable and Type-grounded code is preferred wherever possible\nClosures should be avoided whenever possible\nNumerical functionality should use the appropriate generic numerical interfaces\nFunctions should capture one underlying principle\nInternal choices should be exposed as options whenever possible\nPrefer code reuse over rewrites whenever possible\nPrefer to not shadow functions\nSpecific Rules\nHigh Level Rules\nGeneral Naming Principles\nComments\nModules\nFunctions\nFunction Argument Precedence\nTests and Continuous Integration\nWhitespace\nNamedTuples\nNumbers\nTernary Operator\nFor loops\nFunction Type Annotations\nStruct Type Annotations\nMacros\nTypes and Type Annotations\nPackage version specifications\nDocumentation\nError Handling\nArrays\nLine Endings\nVS-Code Settings\nJuliaFormatter\nReferences","category":"page"},{"location":"#Code-Style-Badge","page":"SciML Style Guide for Julia","title":"Code Style Badge","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Let contributors know your project is following the SciML Style Guide by adding the badge to your README.md.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"[![SciML Code Style](https://img.shields.io/static/v1?label=code%20style&message=SciML&color=9558b2&labelColor=389826)](https://github.com/SciML/SciMLStyle)","category":"page"},{"location":"#Overarching-Dogmas-of-the-SciML-Style","page":"SciML Style Guide for Julia","title":"Overarching Dogmas of the SciML Style","text":"","category":"section"},{"location":"#Consistency-vs-Adherence","page":"SciML Style Guide for Julia","title":"Consistency vs Adherence","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"According to PEP8:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"But most importantly: know when to be inconsistent â€“ sometimes the style guide just doesn't apply. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don't hesitate to ask!","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Some code within the SciML organization is old, on life support, donated by researchers to be maintained. Consistency is the number one goal, so updating to match the style guide should happen on a repo-by-repo basis, i.e. do not update one file to match the style guide (leaving all other files behind).","category":"page"},{"location":"#Community-Contribution-Guidelines","page":"SciML Style Guide for Julia","title":"Community Contribution Guidelines","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"For a comprehensive set of community contribution guidelines, refer to ColPrac. A relevant point to highlight PRs should do one thing. In the context of style, this means that PRs which update the style of a package's code should not be mixed with fundamental code contributions. This separation makes it easier to ensure that large style improvement are isolated from substantive (and potentially breaking) code changes.","category":"page"},{"location":"#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time","page":"SciML Style Guide for Julia","title":"Open source contributions are allowed to start small and grow over time","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"If the standard for code contributions is that every PR needs to support every possible input type that anyone can think of, the barrier would be too high for newcomers. Instead, the principle is to be as correct as possible to begin with, and grow the generic support over time. All recommended functionality should be tested, any known generality issues should be documented in an issue (and with a @test_broken test when possible). However, a function which is known to not be GPU-compatible is not grounds to block merging, rather its an encouragement for a follow-up PR to improve the general type support!","category":"page"},{"location":"#Generic-code-is-preferred-unless-code-is-known-to-be-specific","page":"SciML Style Guide for Julia","title":"Generic code is preferred unless code is known to be specific","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"For example, the code:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"function f(A, B)\n    for i in 1:length(A)\n        A[i] = A[i] + B[i]\n    end\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"would not be preferred for two reasons. One is that it assumes A uses one-based indexing, which would fail in cases like OffsetArrays and FFTViews. Another issue is that it requires indexing, while not all array types support indexing (for example, CuArrays). A more generic compatible implementation of this function would be to use broadcast, for example:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"function f(A, B)\n    @. A = A + B\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"which would allow support for a wider variety of array types.","category":"page"},{"location":"#Internal-types-should-match-the-types-used-by-users-when-possible","page":"SciML Style Guide for Julia","title":"Internal types should match the types used by users when possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"If f(A) takes the input of some collections and computes an output from those collections, then it should be expected that if the user gives A as an Array, the computation should be done via Arrays. If A was a CuArray, then it should be expected that the computation should be internally done using a CuArray (or appropriately error if not supported). For these reasons, constructing arrays via generic methods, like similar(A), is preferred when writing f instead of using non-generic constructors like Array(undef,size(A)) unless the function is documented as being non-generic.","category":"page"},{"location":"#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible","page":"SciML Style Guide for Julia","title":"Trait definition and adherence to generic interface is preferred when possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Julia provides many different interfaces, for example:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Iteration\nIndexing\nBroadcast","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Those interfaces should be followed when possible. For example, when defining broadcast overloads, one should implement a BroadcastStyle as suggested by the documentation instead of simply attempting to bypass the broadcast system via copyto! overloads.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"When interface functions are missing, these should be added to Base Julia or an interface package, like ArrayInterface.jl. Such traits should be declared and used when appropriate. For example, if a line of code requires mutation, the trait ArrayInterface.ismutable(A) should be checked before attempting to mutate, and informative error messages should be written to capture the immutable case (or, an alternative code which does not mutate should be given).","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"One example of this principle is demonstrated in the generation of Jacobian matrices. In many scientific applications, one may wish to generate a Jacobian cache from the user's input u0. A naive way to generate this Jacobian is J = similar(u0,length(u0),length(u0)). However, this will generate a Jacobian J such that J isa Matrix.","category":"page"},{"location":"#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar","page":"SciML Style Guide for Julia","title":"Macros should be limited and only be used for syntactic sugar","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Macros define new syntax, and for this reason they tend to be less composable than other coding styles and require prior familiarity to be easily understood. One principle to keep in mind is, \"can the person reading the code easily picture what code is being generated?\". For example, a user of Soss.jl may not know what code is being generated by:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"@model (x, Î±) begin\n    Ïƒ ~ Exponential()\n    Î² ~ Normal()\n    y ~ For(x) do xj\n        Normal(Î± + Î² * xj, Ïƒ)\n    end\n    return y\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"and thus using such a macro as the interface is not preferred when possible. However, a macro like @muladd is trivial to picture on a code (it recursively transforms a*b + c to muladd(a,b,c) for more accuracy and efficiency), so using such a macro for example:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"julia> @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))\n:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"is recommended. Some macros in this category are:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"@inbounds\n@muladd\n@view\n@named\n@.\n@..","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Some performance macros, like @simd, @threads, or @turbo from LoopVectorization.jl, make an exception in that their generated code may be foreign to many users. However, they still are classified as appropriate uses as they are syntactic sugar since they do (or should) not change the behavior of the program in measurable ways other than performance.","category":"page"},{"location":"#Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers","page":"SciML Style Guide for Julia","title":"Errors should be caught as high as possible, and error messages should be contextualized for newcomers","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Whenever possible, defensive programming should be used to check for potential errors before they are encountered deeper within a package. For example, if one knows that f(u0,p) will error unless u0 is the size of p, this should be caught at the start of the function to throw a domain specific error, for example \"parameters and initial condition should be the same size\".","category":"page"},{"location":"#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl","page":"SciML Style Guide for Julia","title":"Subpackaging and interface packages is preferred over conditional modules via Requires.jl","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Requires.jl should be avoided at all costs. If an interface package exists, such as ChainRulesCore.jl for defining automatic differentiation rules without requiring a dependency on the whole ChainRules.jl system, or RecipesBase.jl which allows for defining Plots.jl plot recipes without a dependency on Plots.jl, a direct dependency on these interface packages is preferred.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Otherwise, instead of resorting to a conditional dependency using Requires.jl, it is preferred one creates subpackages, i.e. smaller independent packages kept within the same Github repository with independent versioning and package management. An example of this is seen in Optimization.jl which has subpackages like OptimizationBBO.jl for BlackBoxOptim.jl support.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Some important interface packages to know about are:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"ChainRulesCore.jl\nRecipesBase.jl\nArrayInterface.jl\nCommonSolve.jl\nSciMLBase.jl","category":"page"},{"location":"#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable","page":"SciML Style Guide for Julia","title":"Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Mutating codes and non-mutating codes fall into different worlds. When a code is fully immutable, the compiler can better reason about dependencies, optimize the code, and check for correctness. However, many times a code making the fullest use of mutation can outperform even what the best compilers of today can generate. That said, the worst of all worlds is when code mixes mutation with non-mutating code. Not only is this a mishmash of coding styles, it has the potential non-locality and compiler proof issues of mutating code while not fully benefiting from the mutation.","category":"page"},{"location":"#Out-Of-Place-and-Immutability-is-preferred-when-sufficient-performant","page":"SciML Style Guide for Julia","title":"Out-Of-Place and Immutability is preferred when sufficient performant","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Mutation is used to get more performance by decreasing the amount of heap allocations. However, if it's not helpful for heap allocations in a given spot, do not use mutation. Mutation is scary and should be avoided unless it gives an immediate benefit. For example, if matrices are sufficiently large, then A*B is as fast as mul!(C,A,B), and thus writing A*B is preferred (unless the rest of the function is being careful about being fully non-allocating, in which case this should be mul! for consistency).","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Similarly, when defining types, using struct is preferred to mutable struct unless mutating the struct is a common occurrence. Even if mutating the struct is a common occurrence, see whether using SetField.jl is sufficient. The compiler will optimize the construction of immutable structs, and thus this can be more efficient if it's not too much of a code hassle.","category":"page"},{"location":"#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types","page":"SciML Style Guide for Julia","title":"Tests should attempt to cover a wide gamut of input types","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Code coverage numbers are meaningless if one does not consider the input types. For example, one can hit all of the code with Array, but that does not test whether CuArray is compatible! Thus it's always good to think of coverage not in terms of lines of code but in terms of type coverage. A good list of number types to think about are:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Float64\nFloat32\nComplex\nDual\nBigFloat","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Array types to think about testing are:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Array\nOffsetArray\nCuArray","category":"page"},{"location":"#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package","page":"SciML Style Guide for Julia","title":"When in doubt, a submodule should become a subpackage or separate package","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Keep packages to one core idea. If there's something separate enough to be a submodule, could it instead be a separate well-tested and documented package to be used by other packages? Most likely yes.","category":"page"},{"location":"#Globals-should-be-avoided-whenever-possible","page":"SciML Style Guide for Julia","title":"Globals should be avoided whenever possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Global variables should be avoided whenever possible. When required, global variables should be consts and have an all uppercase name separated with underscores (e.g. MY_CONSTANT). They should be defined at the top of the file, immediately after imports and exports but before an __init__ function. If you truly want mutable global style behaviour you may want to look into mutable containers.","category":"page"},{"location":"#Type-stable-and-Type-grounded-code-is-preferred-wherever-possible","page":"SciML Style Guide for Julia","title":"Type-stable and Type-grounded code is preferred wherever possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Type-stable and type-grounded code helps the compiler create not only more optimized code, but also faster to compile code. Always keep containers well-typed, functions specializing on the appropriate arguments, and types concrete.","category":"page"},{"location":"#Closures-should-be-avoided-whenever-possible","page":"SciML Style Guide for Julia","title":"Closures should be avoided whenever possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Closures can cause accidental type instabilities that are difficult to track down and debug; in the long run it saves time to always program defensively and avoid writing closures in the first place, even when a particular closure would not have been problematic. A similar argument applies to reading code with closures; if someone is looking for type instabilities, this is faster to do when code does not contain closures. Furthermore, if you want to update variables in an outer scope, do so explicitly with Refs or self defined structs. For example,","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"map(Base.Fix2(getindex, i), vector_of_vectors)","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"is preferred over","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"map(v -> v[i], vector_of_vectors)","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"or","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"[v[i] for v in vector_of_vectors]","category":"page"},{"location":"#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces","page":"SciML Style Guide for Julia","title":"Numerical functionality should use the appropriate generic numerical interfaces","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"While you can use A\\b to do a linear solve inside of a package, that does not mean that you should. This interface is only sufficient for performing factorizations, and so that limits the scaling choices, the types of A that can be supported, etc. Instead, linear solves within packages should use LinearSolve.jl. Similarly, nonlinear solves should use NonlinearSolve.jl. Optimization should use Optimization.jl. Etc. This allows the full generic choice to be given to the user without depending on every solver package (effectively recreating the generic interfaces within each package).","category":"page"},{"location":"#Functions-should-capture-one-underlying-principle","page":"SciML Style Guide for Julia","title":"Functions should capture one underlying principle","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Functions mean one thing. Every dispatch of + should be \"the meaning of addition on these types\". While in theory you could add dispatches to + that mean something different, that will fail in generic code for which + means addition. Thus for generic code to work, code needs to adhere to one meaning for each function. Every dispatch should be an instantiation of that meaning.","category":"page"},{"location":"#Internal-choices-should-be-exposed-as-options-whenever-possible","page":"SciML Style Guide for Julia","title":"Internal choices should be exposed as options whenever possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Whenever possible, numerical values and choices within scripts should be exposed as options to the user. This promotes code reusability beyond the few cases the author may have expected.","category":"page"},{"location":"#Prefer-code-reuse-over-rewrites-whenever-possible","page":"SciML Style Guide for Julia","title":"Prefer code reuse over rewrites whenever possible","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"If a package has a function you need, use the package. Add a dependency if you need to. If the function is missing a feature, prefer to add that feature to said package and then add it as a dependency. If the dependency is potentially troublesome, for example because it has a high load time, prefer to spend time helping said package fix these issues and add the dependency. Only when it does not seem possible to make the package \"good enough\" should using the package be abandoned. If it is abandoned, consider building a new package for this functionality as you need it, and then make it a dependency.","category":"page"},{"location":"#Prefer-to-not-shadow-functions","page":"SciML Style Guide for Julia","title":"Prefer to not shadow functions","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Two functions can have the same name in Julia by having different namespaces. For example, X.f and Y.f can be two different functions, with different dispatches, but the same name. This should be avoided whenever possible. Instead of creating MyPackage.sort, consider adding dispatches to Base.sort for your types if these new dispatches match the underlying principle of the function. If it doesn't, prefer to use a different name. While using MyPackage.sort is not conflicting, it is going to be confusing for most people unfamiliar with your code, so MyPackage.special_sort would be more helpful to newcomers reading the code.","category":"page"},{"location":"#Specific-Rules","page":"SciML Style Guide for Julia","title":"Specific Rules","text":"","category":"section"},{"location":"#High-Level-Rules","page":"SciML Style Guide for Julia","title":"High Level Rules","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Use 4 spaces per indentation level, no tabs.\nTry to adhere to a 92 character line length limit.","category":"page"},{"location":"#General-Naming-Principles","page":"SciML Style Guide for Julia","title":"General Naming Principles","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"All type names should be CamelCase.\nAll struct names should be CamelCase.\nAll module names should be CamelCase.\nAll function names should be snake_case (all lowercase).\nAll variable names should be snake_case (all lowercase).\nAll constant names should be SNAKE_CASE (all uppercase).\nAll abstract type names should begin with Abstract.\nAll type variable names should be a single capital letter, preferably related to the value being typed.\nWhole words are usually better than abbreviations or single letters.\nVariables meant to be internal or private to a package should be denoted by prepending two underscores, i.e. __.\nSingle letters can be okay when naming a mathematical entity, i.e. an entity whose purpose or non-mathematical \"meaning\" is likely only known by downstream callers. For example, a and b would be appropriate names when implementing *(a::AbstractMatrix, b::AbstractMatrix), since the \"meaning\" of those arguments (beyond their mathematical meaning as matrices, which is already described by the type) is only known by the caller.\nUnicode is fine within code where it increases legibility, but in no case should Unicode be used in public APIs. This is to allow support for terminals which cannot use Unicode: if a keyword argument must be Î·, then it can be exclusionary to uses on clusters which do not support Unicode inputs.","category":"page"},{"location":"#Comments","page":"SciML Style Guide for Julia","title":"Comments","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"TODO to mark todo comments and XXX to mark comments about currently broken code\nQuote code in comments using backticks (e.g. variable_name).\nWhen possible, code should be changed to incorporate information that would have been in a comment. For example, instead of commenting # fx applies the effects to a tree, simply change the function and variable names apply_effects(tree).\nComments referring to Github issues and PRs should add the URL in the comments. Only use inline comments if they fit within the line length limit. If your comment cannot be fitted inline then place the comment above the content to which it refers:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\n\n# Number of nodes to predict. Again, an issue with the workflow order. Should be updated\n# after data is fetched.\np = 1\n\n# No:\n\np = 1  # Number of nodes to predict. Again, an issue with the workflow order. Should be\n# updated after data is fetched.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"In general, comments above a line of code or function are preferred to inline comments.","category":"page"},{"location":"#Modules","page":"SciML Style Guide for Julia","title":"Modules","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Module imports should occur at the top of a file or right after a module declaration.\nModule imports in packages should either use import or explicitly declare the imported functionality, for example using Dates: Year, Month, Week, Day, Hour, Minute, Second, Millisecond.\nImport and using statements should be separated, and should be divided by a blank line.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nimport A: a\nimport C\n\nusing B\nusing D: d\n\n# No:\nimport A: a\nusing B\nimport C\nusing D: d","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Large sets of imports are preferred to be written in space filling lines separated by commas.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nusing A, B, C, D\n\n# No:\nusing A\nusing B\nusing C\nusing D\n\n# No:\nusing A,\n      B,\n      C,\n      D","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Exported variables should be considered as part of the public API, and changing their interface constitutes a breaking change.\nAny exported variables should be sufficiently unique. I.e., do not export f as that is very likely to clash with something else.\nA file that includes the definition of a module, should not include any other code that runs outside that module. i.e. the module should be declared at the top of the file with the module keyword and end at the bottom of the file. No other code before, or after (except for module docstring before). In this case the code with in the module block should not be indented.\nSometimes, e.g. for tests, or for namespacing an enumeration, it is desirable to declare a submodule midway through a file. In this case the code within the submodule should be indented.","category":"page"},{"location":"#Functions","page":"SciML Style Guide for Julia","title":"Functions","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Only use short-form function definitions when they fit on a single line:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nfoo(x::Int64) = abs(x) + 3\n\n# No:\nfoobar(array_data::AbstractArray{T}, item::T) where {T <: Int64} = T[\n    abs(x) * abs(item) + 3 for x in array_data\n]","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Inputs should be required unless a default is historically expected or likely to be applicable to >95% of use cases. For example, the tolerance of a differential equation solver was set to a default of abstol=1e-6,reltol=1e-3 as a generally correct plot in most cases, and is an expectation from back in the 90's. In that case, using the historically expected and most often useful default tolerances is justified. However, if one implements GradientDescent, the learning rate needs to be adjusted for each application (based on the size of the gradient), and thus a default of GradientDescent(learning_rate = 1) is not recommended.\nArguments which do not have defaults should be preferably made into positional arguments. The newer syntax of required keyword arguments can be useful but should not be abused. Notable exceptions are cases where \"either or\" arguments are accepted, for example of defining g or dgdu is sufficient, then making them both keyword arguments with = nothing and checking that either is not nothing (and throwing an appropriate error) is recommended if distinct dispatches with different types is not possible. \nWhen calling a function always separate your keyword arguments from your positional arguments with a semicolon. This avoids mistakes in ambiguous cases (such as splatting a Dict).\nWhen writing a function that sends a lot of keyword arguments to another function, say sending keyword arguments to a differential equation solver, use a named tuple keyword argument instead of splatting the keyword arguments. For example, use diffeq_solver_kwargs = (; abstol=1e-6, reltol=1e-6,) as the API and use solve(prob, alg; diffeq_solver_kwargs...) instead of splatting all keyword arguments.\nFunctions which mutate arguments should be appended with !.\nAvoid type piracy. I.e., do not add methods to functions you don't own on types you don't own. Either own the types or the function.\nFunctions should prefer instances instead of types for arguments. For example, for a solver type Tsit5, the interface should use solve(prob,Tsit5()), not solve(prob,Tsit5). The reason for this is multifold. For one, passing a type has different specialization rules, so functionality can be slower unless ::Type{Tsit5} is written in the dispatches which use it. Secondly, this allows for default and keyword arguments to extend the choices, which may become useful for some types down the line. Using this form allows adding more options in a non-breaking manner.\nIf the number of arguments is too large to fit into a 92 character line, then use as many arguments as possible within a line and start each new row with the same indentation, preferably at the same column as the ( but this can be moved left if the function name is very long. For example:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes\nfunction my_large_function(argument1, argument2,\n                           argument3, argument4,\n                           argument5, x, y, z)\n\n# No\nfunction my_large_function(argument1,\n                           argument2,\n                           argument3,\n                           argument4,\n                           argument5,\n                           x,\n                           y,\n                           z)","category":"page"},{"location":"#Function-Argument-Precedence","page":"SciML Style Guide for Julia","title":"Function Argument Precedence","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Function argument. Putting a function argument first permits the use of do blocks for passing multiline anonymous functions.\nI/O stream. Specifying the IO object first permits passing the function to functions such as sprint, e.g. sprint(show, x).\nInput being mutated. For example, in fill!(x, v), x is the object being mutated and it appears before the value to be inserted into x.\nType. Passing a type typically means that the output will have the given type. In parse(Int, \"1\"), the type comes before the string to parse. There are many such examples where the type appears first, but it's useful to note that in read(io, String), the IO argument appears before the type, which is in keeping with the order outlined here.\nInput not being mutated. In fill!(x, v), v is not being mutated and it comes after x.\nKey. For associative collections, this is the key of the key-value pair(s). For other indexed collections, this is the index.\nValue. For associative collections, this is the value of the key-value pair(s). In cases like fill!(x, v), this is v.\nEverything else. Any other arguments.\nVarargs. This refers to arguments that can be listed indefinitely at the end of a function call. For example, in Matrix{T}(undef, dims), the dimensions can be given as a Tuple, e.g. Matrix{T}(undef, (1,2)), or as Varargs, e.g. Matrix{T}(undef, 1, 2).\nKeyword arguments. In Julia keyword arguments have to come last anyway in function definitions; they're listed here for the sake of completeness.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"The vast majority of functions will not take every kind of argument listed above; the numbers merely denote the precedence that should be used for any applicable arguments to a function.","category":"page"},{"location":"#Tests-and-Continuous-Integration","page":"SciML Style Guide for Julia","title":"Tests and Continuous Integration","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"The high level runtests.jl file should only be used to shuttle to other test files.\nEvery set of tests should be included into a @safetestset. A standard @testset does not fully enclose all defined values, such as functions defined in a @testset, and thus can \"leak\".\nTest includes should be written in one line, for example:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"@time @safetestset \"Jacobian Tests\" begin include(\"interface/jacobian_tests.jl\") end","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Every test script should be fully reproducible in isolation. I.e., one should be able to copy paste that script and receive the results.\nTest scripts should be grouped based on categories, for example tests of the interface vs tests for numerical convergence. Grouped tests should be kept in the same folder.\nA GROUP environment variable should be used to specify test groups for parallel testing in continuous integration. A fallback group All should be used to specify all of the tests that should be run when a developer runs ]test Package locally. As an example, see the OrdinaryDiffEq.jl test structure\nTests should include downstream tests to major packages which use the functionality, to ensure continued support. Any update which breaks the downstream tests should follow with a notification to the downstream package of why the support was broken (preferably in the form of a PR which fixes support), and the package should be given a major version bump in the next release if the changed functionality was part of the public API.\nCI scripts should use the default settings unless required.\nCI scripts should test the Long-Term Support (LTS) release and the current stable release. Nightly tests are only necessary for packages which a heavy reliance on specific compiler details.\nAny package supporting GPUs should include continuous integration for GPUs.\nDoctests should be enabled except for on the examples which are computationally-prohibitive to have as part of continuous integration.","category":"page"},{"location":"#Whitespace","page":"SciML Style Guide for Julia","title":"Whitespace","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Avoid extraneous whitespace immediately inside parentheses, square brackets or braces.\n```julia\nYes:\nspam(ham[1], [eggs])\nNo:\nspam( ham[ 1 ], [ eggs ] )   ```\nAvoid extraneous whitespace immediately before a comma or semicolon:\n```julia\nYes:\nif x == 4 @show(x, y); x, y = y, x end\nNo:\nif x == 4 @show(x , y) ; x , y = y , x end   ```\nAvoid whitespace around : in ranges. Use brackets to clarify expressions on either side.\n```julia\nYes:\nham[1:9]   ham[9:-3:0]   ham[1:step:end]   ham[lower:upper-1]   ham[lower:upper - 1]   ham[lower:(upper + offset)]   ham[(lower + offset):(upper + offset)]\nNo:\nham[1: 9]   ham[9 : -3: 1]   ham[lower : upper - 1]   ham[lower + offset:upper + offset]  # Avoid as it is easy to read as ham[lower + (offset:upper) + offset]   ```\nAvoid using more than one space around an assignment (or other) operator to align it with another:\n```julia\nYes:\nx = 1   y = 2   long_variable = 3\nNo:\nx             = 1   y             = 2   long_variable = 3   ```\nSurround most binary operators with a single space on either side: assignment (=), updating operators (+=, -=, etc.), numeric comparisons operators (==, <, >, !=, etc.), lambda operator (->). Binary operators may be excluded from this guideline include: the range operator (:), rational operator (//), exponentiation operator (^), optional arguments/keywords (e.g. f(x = 1; y = 2)).\n```julia\nYes:\ni = j + 1   submitted += 1   x^2 < y\nNo:\ni=j+1   submitted +=1   x^2<y   ```\nAvoid using whitespace between unary operands and the expression:\n```julia\nYes:\n-1   [1 0 -1]\nNo:\n1\n[1 0 - 1]  # Note: evaluates to [1 -1]   ```\nAvoid extraneous empty lines. Avoid empty lines between single line method definitions   and otherwise separate functions with one empty line, plus a comment if required:\n```julia\nYes:\nNote: an empty line before the first long-form domaths method is optional.\ndomaths(x::Number) = x + 5   domaths(x::Int) = x + 10   function domaths(x::String)       return \"A string is a one-dimensional extended object postulated in string theory.\"   end\ndophilosophy() = \"Why?\"\nNo:\ndomath(x::Number) = x + 5\ndomath(x::Int) = x + 10","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"function domath(x::String)\n    return \"A string is a one-dimensional extended object postulated in string theory.\"\nend\n\n\ndophilosophy() = \"Why?\"\n```","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Function calls which cannot fit on a single line within the line limit should be broken up such that the lines containing the opening and closing brackets are indented to the same level while the parameters of the function are indented one level further. In most cases the arguments and/or keywords should each be placed on separate lines. Note that this rule conflicts with the typical Julia convention of indenting the next line to align with the open bracket in which the parameter is contained. If working in a package with a different convention follow the convention used in the package over using this guideline.\n```julia\nYes:\nf(a, b)   constraint = conicform!(SOCElemConstraint(temp2 + temp3, temp2 - temp3, 2 * temp1),                            uniqueconic_forms)\nNo:\nNote: f call is short enough to be on a single line\nf(       a,       b,   )   constraint = conicform!(SOCElemConstraint(temp2 + temp3,                                              temp2 - temp3, 2 * temp1),                            uniqueconic_forms)   ```\nGroup similar one line statements together.\n```julia\nYes:\nfoo = 1   bar = 2   baz = 3\nNo:\nfoo = 1\nbar = 2\nbaz = 3   ```\nUse blank-lines to separate different multi-line blocks.\n```julia\nYes:\nif foo       println(\"Hi\")   end\nfor i in 1:10       println(i)   end\nNo:\nif foo       println(\"Hi\")   end   for i in 1:10       println(i)   end   ```\nAfter a function definition, and before an end statement do not include a blank line.\n```julia\nYes:\nfunction foo(bar::Int64, baz::Int64)       return bar + baz   end\nNo:\nfunction foo(bar::Int64, baz::Int64)\n  return bar + baz\nend\nNo:\nfunction foo(bar::In64, baz::Int64)       return bar + baz\nend   ```\nUse line breaks between control flow statements and returns.\n```julia\nYes:\nfunction foo(bar; verbose = false)       if verbose           println(\"baz\")       end\n  return bar\nend\nOk:\nfunction foo(bar; verbose = false)       if verbose           println(\"baz\")       end       return bar   end   ```","category":"page"},{"location":"#NamedTuples","page":"SciML Style Guide for Julia","title":"NamedTuples","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"The = character in NamedTuples should be spaced as in keyword arguments. Space should be put between the name and its value. The empty NamedTuple should be written NamedTuple() not (;)","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nxy = (x = 1, y = 2)\nx = (x = 1,)  # Trailing comma required for correctness.\nx = (; kwargs...)  # Semicolon required to splat correctly.\n\n# No:\nxy = (x=1, y=2)\nxy = (;x=1,y=2)","category":"page"},{"location":"#Numbers","page":"SciML Style Guide for Julia","title":"Numbers","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Floating-point numbers should always include a leading and/or trailing zero:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\n0.1\n2.0\n3.0f0\n\n# No:\n.1\n2.\n3.f0","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Always prefer the type Int to Int32 or Int64 unless one has a specific reason to choose the bit size.","category":"page"},{"location":"#Ternary-Operator","page":"SciML Style Guide for Julia","title":"Ternary Operator","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Ternary operators (?:) should generally only consume a single line. Do not chain multiple ternary operators. If chaining many conditions, consider using an if-elseif-else conditional, dispatch, or a dictionary.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nfoobar = foo == 2 ? bar : baz\n\n# No:\nfoobar = foo == 2 ?\n    bar :\n    baz\nfoobar = foo == 2 ? bar : foo == 3 ? qux : baz","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"As an alternative, you can use a compound boolean expression:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nfoobar = if foo == 2\n    bar\nelse\n    baz\nend\n\nfoobar = if foo == 2\n    bar\nelseif foo == 3\n    qux\nelse\n    baz\nend","category":"page"},{"location":"#For-loops","page":"SciML Style Guide for Julia","title":"For loops","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"For loops should always use in, never = or âˆˆ. This also applies to list and generator comprehensions","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes\nfor i in 1:10\n    #...\nend\n\n[foo(x) for x in xs]\n\n# No:\nfor i = 1:10\n    #...\nend\n\n[foo(x) for x âˆˆ xs]","category":"page"},{"location":"#Function-Type-Annotations","page":"SciML Style Guide for Julia","title":"Function Type Annotations","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Annotations for function definitions should be as general as possible.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nsplicer(arr::AbstractArray, step::Integer) = arr[begin:step:end]\n\n# No:\nsplicer(arr::Array{Int}, step::Int) = arr[begin:step:end]","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Using as generic types as possible allows for a variety of inputs and allows your code to be more general:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"julia> splicer(1:10, 2)\n1:2:9\n\njulia> splicer([3.0, 5, 7, 9], 2)\n2-element Array{Float64,1}:\n 3.0\n 7.0","category":"page"},{"location":"#Struct-Type-Annotations","page":"SciML Style Guide for Julia","title":"Struct Type Annotations","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Annotations on type fields need to be given a little more thought since field access is not concrete unless the compiler can infer the type (see type-dispatch design for details). Since well-inferred code is preferred, abstract type annotations, i.e.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"mutable struct MySubString <: AbstractString\n    string::AbstractString\n    offset::Integer\n    endof::Integer\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"are not recommended. Instead a concretely-typed struct:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"mutable struct MySubString <: AbstractString\n    string::String\n    offset::Int\n    endof::Int\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"is preferred. If generality is required, then parametric typing is preferred, i.e.:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"mutable struct MySubString{T<:Integer} <: AbstractString\n    string::String\n    offset::T\n    endof::T\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Untyped fields should be explicitly typed Any, i.e.:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"struct StructA\n    a::Any\nend","category":"page"},{"location":"#Macros","page":"SciML Style Guide for Julia","title":"Macros","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Do not add spaces between assignments when there are multiple assignments.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Yes:\n@parameters a = b\n@parameters a=b c=d\n\nNo:\n@parameters a = b c = d","category":"page"},{"location":"#Types-and-Type-Annotations","page":"SciML Style Guide for Julia","title":"Types and Type Annotations","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Avoid elaborate union types. Vector{Union{Int,AbstractString,Tuple,Array}} should probably be Vector{Any}. This will reduce the amount of extra strain on compilation checking many branches.\nUnions should be kept to two or three types only for branch splitting. Unions of three types should be kept to a minimum for compile times.\nDo not use === to compare types. Use isa or <: instead.","category":"page"},{"location":"#Package-version-specifications","page":"SciML Style Guide for Julia","title":"Package version specifications","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Use Semantic Versioning\nFor simplicity, avoid including the default caret specifier when specifying package version requirements.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"# Yes:\nDataFrames = \"0.17\"\n\n# No:\nDataFrames = \"^0.17\"","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"For accuracy, do not use constructs like >= to avoid upper bounds.\nEvery dependency should have a bound.\nAll packages should use CompatHelper and attempt to stay up to date with the dependencies.\nThe lower bound on dependencies should be the last tested version.","category":"page"},{"location":"#Documentation","page":"SciML Style Guide for Julia","title":"Documentation","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Documentation should always attempt to be at the highest level possible. I.e., documentation of an interface that all methods follow is preferred to documenting every method, and documenting the interface of an abstract type is preferred to documenting all of the subtypes individually. All instances should then refer to the higher level documentation.\nDocumentation should use Documenter.jl.\nTutorials should come before reference materials.\nEvery package should have a starting tutorial that covers \"the 90% use case\", i.e. the ways that most people will want to use the package.\nThe tutorial should show a complete workflow and be opinionated in said workflow. For example, when writing a tutorial about a simulator, pick a plotting package and show to plot it.\nVariable names in tutorials are important. If you use u0, then all other codes will copy that naming scheme. Show potential users the right way to use your code with the right naming.\nWhen applicable, tutorials on how to use the \"high performance advanced features\" should be separated from the beginning tutorial.\nAll documentation should summarize contents before going into specifics of API docstrings.\nMost modules, types and functions should have docstrings.\nPrefer documenting accessor functions instead of fields when possible. Documented fields are part of the public API and changing their contents/name constitutes a breaking change.\nOnly exported functions are required to be documented.\nAvoid documenting methods common overloads ==.\nTry to document a function and not individual methods where possible as typically all methods will have similar docstrings.\nIf you are adding a method to a function which already has a docstring only add a docstring if the behaviour of your function deviates from the existing docstring.\nDocstrings are written in Markdown and should be concise.\nDocstring lines should be wrapped at 92 characters.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n    bar(x[, y])\n\nCompute the Bar index between `x` and `y`. If `y` is missing, compute the Bar index between\nall pairs of columns of `x`.\n\"\"\"\nfunction bar(x, y) ...","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"It is recommended that you have a blank line between the headings and the content when the content is of sufficient length.\nTry to be consistent within a docstring whether you use this additional whitespace.\nFollow one of the following templates for types and functions when possible:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Type Template (should be skipped if is redundant with the constructor(s) docstring):","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n    MyArray{T, N}\n\nMy super awesome array wrapper!\n\n# Fields\n- `data::AbstractArray{T, N}`: stores the array being wrapped\n- `metadata::Dict`: stores metadata about the array\n\"\"\"\nstruct MyArray{T, N} <: AbstractArray{T, N}\n    data::AbstractArray{T, N}\n    metadata::Dict\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Function Template (only required for exported functions):","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n    mysearch(array::MyArray{T}, val::T; verbose = true) where {T} -> Int\n\nSearches the `array` for the `val`. For some reason we don't want to use Julia's\nbuiltin search :)\n\n# Arguments\n- `array::MyArray{T}`: the array to search\n- `val::T`: the value to search for\n\n# Keywords\n- `verbose::Bool = true`: print out progress details\n\n# Returns\n- `Int`: the index where `val` is located in the `array`\n\n# Throws\n- `NotFoundError`: I guess we could throw an error if `val` isn't found.\n\"\"\"\nfunction mysearch(array::AbstractArray{T}, val::T) where {T}\n    ...\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"The @doc doc\"\"\" \"\"\" formulation from the Markdown standard library should be used whenever there is LaTeX.\nOnly public fields of types must be documented. Undocumented fields are considered non-public internals.\nIf your method contains lots of arguments or keywords you may want to exclude them from the method signature on the first line and instead use args... and/or kwargs....","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n    Manager(args...; kwargs...) -> Manager\n\nA cluster manager which spawns workers.\n\n# Arguments\n\n- `min_workers::Integer`: The minimum number of workers to spawn or an exception is thrown\n- `max_workers::Integer`: The requested number of workers to spawn\n\n# Keywords\n\n- `definition::AbstractString`: Name of the job definition to use. Defaults to the\n    definition used within the current instance.\n- `name::AbstractString`: ...\n- `queue::AbstractString`: ...\n\"\"\"\nfunction Manager(...)\n    ...\nend","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Feel free to document multiple methods for a function within the same docstring. Be careful to only do this for functions you have defined.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n    Manager(max_workers; kwargs...)\n    Manager(min_workers:max_workers; kwargs...)\n    Manager(min_workers, max_workers; kwargs...)\n\nA cluster manager which spawns workers.\n\n# Arguments\n\n- `min_workers::Int`: The minimum number of workers to spawn or an exception is thrown\n- `max_workers::Int`: The requested number of workers to spawn\n\n# Keywords\n\n- `definition::AbstractString`: Name of the job definition to use. Defaults to the\n    definition used within the current instance.\n- `name::AbstractString`: ...\n- `queue::AbstractString`: ...\n\"\"\"\nfunction Manager end\n","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"If the documentation for bullet-point exceeds 92 characters the line should be wrapped and slightly indented. Avoid aligning the text to the :.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"\"\"\"\n...\n\n# Keywords\n- `definition::AbstractString`: Name of the job definition to use. Defaults to the\n    definition used within the current instance.\n\"\"\"","category":"page"},{"location":"#Error-Handling","page":"SciML Style Guide for Julia","title":"Error Handling","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"error(\"string\") should be avoided. Defining and throwing exception types is preferred. See the manual on exceptions for more details.\nTry to avoid try/catch. Use it as minimally as possible. Attempt to catch potential issues before running code, not after.","category":"page"},{"location":"#Arrays","page":"SciML Style Guide for Julia","title":"Arrays","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Avoid splatting (...) whenever possible. Prefer iterators such as collect, vcat, hcat, etc. instead.","category":"page"},{"location":"#Line-Endings","page":"SciML Style Guide for Julia","title":"Line Endings","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Always use Unix style \\n line ending.","category":"page"},{"location":"#VS-Code-Settings","page":"SciML Style Guide for Julia","title":"VS-Code Settings","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"If you are a user of VS Code we recommend that you have the following options in your Julia syntax specific settings. To modify these settings open your VS Code Settings with <kbd>CMD</kbd>+<kbd>,</kbd> (Mac OS) or <kbd>CTRL</kbd>+<kbd>,</kbd> (other OS), and add to your settings.json:","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"{\n    \"[julia]\": {\n        \"editor.detectIndentation\": false,\n        \"editor.insertSpaces\": true,\n        \"editor.tabSize\": 4,\n        \"files.insertFinalNewline\": true,\n        \"files.trimFinalNewlines\": true,\n        \"files.trimTrailingWhitespace\": true,\n        \"editor.rulers\": [92],\n        \"files.eol\": \"\\n\"\n    },\n}","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Additionally you may find the Julia VS-Code plugin useful.","category":"page"},{"location":"#JuliaFormatter","page":"SciML Style Guide for Julia","title":"JuliaFormatter","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Note: the sciml style is only available in JuliaFormatter v1.0 or later","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"One can add .JuliaFormatter.toml with the content","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"style = \"sciml\"","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"in the root of a repository, and run","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"using JuliaFormatter, SomePackage\nformat(joinpath(dirname(pathof(SomePackage)), \"..\"))","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"to format the package automatically.","category":"page"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Add FormatCheck.yml to enable the formatting CI. The CI will fail if the repository needs additional formatting. Thus, one should run format before committing.","category":"page"},{"location":"#References","page":"SciML Style Guide for Julia","title":"References","text":"","category":"section"},{"location":"","page":"SciML Style Guide for Julia","title":"SciML Style Guide for Julia","text":"Many of these style choices were derived from the Julia style guide, the YASGuide, and the Blue style guide.","category":"page"}]
}
